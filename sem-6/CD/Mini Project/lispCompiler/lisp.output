State 24 conflicts: 1 shift/reduce
State 46 conflicts: 1 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: stList

    2 stList: stList stmt
    3       | %empty

    4 stmt: fnCall
    5     | formatSt
    6     | decl
    7     | sExpn
    8     | fnDecl
    9     | blockSt
   10     | returnSt
   11     | decisionSt
   12     | loopSt

   13 paramList: paramList optionalSQ seOrAtom
   14          | %empty

   15 atomList: atomList ATOM
   16         | %empty

   17 fnCall: LP ATOM paramList RP
   18       | LP ATOM fnCall RP

   19 optionalSQ: SQ
   20           | %empty

   21 decl: LP SETQ ATOM sExpn RP
   22     | LP DEFV ATOM sExpn RP

   23 formatSt: LP FORMAT TRUE LIT paramList RP

   24 fnDecl: LP DEFM ATOM LP atomList RP optionalLIT stList RP

   25 optionalLIT: LIT
   26            | %empty

   27 sExpn: LP arithOP paramList RP
   28      | LP INCF ATOM NUM RP
   29      | LP DECF ATOM NUM RP
   30      | LP NOT seOrAtom RP
   31      | LP LNOR seOrAtom seOrAtom RP
   32      | LP logicalOP paramList RP
   33      | NUM
   34      | TRUE
   35      | FALSE

   36 seOrAtom: sExpn
   37         | ATOM

   38 arithOP: OP
   39        | MOD
   40        | MAX
   41        | MIN

   42 logicalOP: AND
   43          | OR
   44          | LA
   45          | LO
   46          | LXOR
   47          | LEQV
   48          | GT
   49          | GTE
   50          | NE
   51          | EQ
   52          | LT
   53          | LTE

   54 decisionSt: LP IF seOrAtom stList RP
   55           | LP COND testCases RP
   56           | LP WHEN sExpn stList RP

   57 testCases: testCases LP sExpn stList RP
   58          | %empty

   59 blockSt: LP BLOCK ATOM stList RP

   60 loopSt: LP LOOP forConstructs loopStList RP
   61       | LP LOOP stList RP

   62 loopStList: loopStList execLoop
   63           | %empty

   64 execLoop: DO stmt
   65         | COLLECT LP atomList RP

   66 forConstructs: forConstructs FOR ATOM IN SQ LP paramList RP
   67              | %empty

   68 returnSt: LP RETURN ATOM optionalRetVal RP

   69 optionalRetVal: seOrAtom
   70               | %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
MOD (258) 39
INCF (259) 28
DECF (260) 29
TRUE (261) 23 34
FALSE (262) 35
DEFM (263) 24
SETQ (264) 21
OP (265) 38
NUM (266) 28 29 33
LP (267) 17 18 21 22 23 24 27 28 29 30 31 32 54 55 56 57 59 60 61 65
    66 68
RP (268) 17 18 21 22 23 24 27 28 29 30 31 32 54 55 56 57 59 60 61 65
    66 68
LIT (269) 23 25
ATOM (270) 15 17 18 21 22 24 28 29 37 59 66 68
DEFV (271) 22
FORMAT (272) 23
SQ (273) 19 66
EQ (274) 51
NE (275) 50
GT (276) 48
GTE (277) 49
LT (278) 52
LTE (279) 53
MAX (280) 40
MIN (281) 41
AND (282) 42
OR (283) 43
NOT (284) 30
LA (285) 44
LO (286) 45
LXOR (287) 46
LNOR (288) 31
LEQV (289) 47
IF (290) 54
BLOCK (291) 59
RETURN (292) 68
FOR (293) 66
LOOP (294) 60 61
DO (295) 64
IN (296) 66
COLLECT (297) 65
COND (298) 55
WHEN (299) 56


Nonterminals, with rules where they appear

$accept (45)
    on left: 0
program (46)
    on left: 1, on right: 0
stList (47)
    on left: 2 3, on right: 1 2 24 54 56 57 59 61
stmt (48)
    on left: 4 5 6 7 8 9 10 11 12, on right: 2 64
paramList (49)
    on left: 13 14, on right: 13 17 23 27 32 66
atomList (50)
    on left: 15 16, on right: 15 24 65
fnCall (51)
    on left: 17 18, on right: 4 18
optionalSQ (52)
    on left: 19 20, on right: 13
decl (53)
    on left: 21 22, on right: 6
formatSt (54)
    on left: 23, on right: 5
fnDecl (55)
    on left: 24, on right: 8
optionalLIT (56)
    on left: 25 26, on right: 24
sExpn (57)
    on left: 27 28 29 30 31 32 33 34 35, on right: 7 21 22 36 56 57
seOrAtom (58)
    on left: 36 37, on right: 13 30 31 54 69
arithOP (59)
    on left: 38 39 40 41, on right: 27
logicalOP (60)
    on left: 42 43 44 45 46 47 48 49 50 51 52 53, on right: 32
decisionSt (61)
    on left: 54 55 56, on right: 11
testCases (62)
    on left: 57 58, on right: 55 57
blockSt (63)
    on left: 59, on right: 9
loopSt (64)
    on left: 60 61, on right: 12
loopStList (65)
    on left: 62 63, on right: 60 62
execLoop (66)
    on left: 64 65, on right: 62
forConstructs (67)
    on left: 66 67, on right: 60 66
returnSt (68)
    on left: 68, on right: 10
optionalRetVal (69)
    on left: 69 70, on right: 68


State 0

    0 $accept: . program $end
    1 program: . stList
    2 stList: . stList stmt
    3       | . %empty

    $default  reduce using rule 3 (stList)

    program  go to state 1
    stList   go to state 2


State 1

    0 $accept: program . $end

    $end  shift, and go to state 3


State 2

    1 program: stList .  [$end]
    2 stList: stList . stmt
    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   59 blockSt: . LP BLOCK ATOM stList RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7

    $default  reduce using rule 1 (program)

    stmt        go to state 8
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 3

    0 $accept: program $end .

    $default  accept


State 4

   34 sExpn: TRUE .

    $default  reduce using rule 34 (sExpn)


State 5

   35 sExpn: FALSE .

    $default  reduce using rule 35 (sExpn)


State 6

   33 sExpn: NUM .

    $default  reduce using rule 33 (sExpn)


State 7

   17 fnCall: LP . ATOM paramList RP
   18       | LP . ATOM fnCall RP
   21 decl: LP . SETQ ATOM sExpn RP
   22     | LP . DEFV ATOM sExpn RP
   23 formatSt: LP . FORMAT TRUE LIT paramList RP
   24 fnDecl: LP . DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: LP . arithOP paramList RP
   28      | LP . INCF ATOM NUM RP
   29      | LP . DECF ATOM NUM RP
   30      | LP . NOT seOrAtom RP
   31      | LP . LNOR seOrAtom seOrAtom RP
   32      | LP . logicalOP paramList RP
   38 arithOP: . OP
   39        | . MOD
   40        | . MAX
   41        | . MIN
   42 logicalOP: . AND
   43          | . OR
   44          | . LA
   45          | . LO
   46          | . LXOR
   47          | . LEQV
   48          | . GT
   49          | . GTE
   50          | . NE
   51          | . EQ
   52          | . LT
   53          | . LTE
   54 decisionSt: LP . IF seOrAtom stList RP
   55           | LP . COND testCases RP
   56           | LP . WHEN sExpn stList RP
   59 blockSt: LP . BLOCK ATOM stList RP
   60 loopSt: LP . LOOP forConstructs loopStList RP
   61       | LP . LOOP stList RP
   68 returnSt: LP . RETURN ATOM optionalRetVal RP

    MOD     shift, and go to state 18
    INCF    shift, and go to state 19
    DECF    shift, and go to state 20
    DEFM    shift, and go to state 21
    SETQ    shift, and go to state 22
    OP      shift, and go to state 23
    ATOM    shift, and go to state 24
    DEFV    shift, and go to state 25
    FORMAT  shift, and go to state 26
    EQ      shift, and go to state 27
    NE      shift, and go to state 28
    GT      shift, and go to state 29
    GTE     shift, and go to state 30
    LT      shift, and go to state 31
    LTE     shift, and go to state 32
    MAX     shift, and go to state 33
    MIN     shift, and go to state 34
    AND     shift, and go to state 35
    OR      shift, and go to state 36
    NOT     shift, and go to state 37
    LA      shift, and go to state 38
    LO      shift, and go to state 39
    LXOR    shift, and go to state 40
    LNOR    shift, and go to state 41
    LEQV    shift, and go to state 42
    IF      shift, and go to state 43
    BLOCK   shift, and go to state 44
    RETURN  shift, and go to state 45
    LOOP    shift, and go to state 46
    COND    shift, and go to state 47
    WHEN    shift, and go to state 48

    arithOP    go to state 49
    logicalOP  go to state 50


State 8

    2 stList: stList stmt .

    $default  reduce using rule 2 (stList)


State 9

    4 stmt: fnCall .

    $default  reduce using rule 4 (stmt)


State 10

    6 stmt: decl .

    $default  reduce using rule 6 (stmt)


State 11

    5 stmt: formatSt .

    $default  reduce using rule 5 (stmt)


State 12

    8 stmt: fnDecl .

    $default  reduce using rule 8 (stmt)


State 13

    7 stmt: sExpn .

    $default  reduce using rule 7 (stmt)


State 14

   11 stmt: decisionSt .

    $default  reduce using rule 11 (stmt)


State 15

    9 stmt: blockSt .

    $default  reduce using rule 9 (stmt)


State 16

   12 stmt: loopSt .

    $default  reduce using rule 12 (stmt)


State 17

   10 stmt: returnSt .

    $default  reduce using rule 10 (stmt)


State 18

   39 arithOP: MOD .

    $default  reduce using rule 39 (arithOP)


State 19

   28 sExpn: LP INCF . ATOM NUM RP

    ATOM  shift, and go to state 51


State 20

   29 sExpn: LP DECF . ATOM NUM RP

    ATOM  shift, and go to state 52


State 21

   24 fnDecl: LP DEFM . ATOM LP atomList RP optionalLIT stList RP

    ATOM  shift, and go to state 53


State 22

   21 decl: LP SETQ . ATOM sExpn RP

    ATOM  shift, and go to state 54


State 23

   38 arithOP: OP .

    $default  reduce using rule 38 (arithOP)


State 24

   13 paramList: . paramList optionalSQ seOrAtom
   14          | . %empty  [TRUE, FALSE, NUM, LP, RP, ATOM, SQ]
   17 fnCall: . LP ATOM paramList RP
   17       | LP ATOM . paramList RP
   18       | . LP ATOM fnCall RP
   18       | LP ATOM . fnCall RP

    LP  shift, and go to state 55

    LP        [reduce using rule 14 (paramList)]
    $default  reduce using rule 14 (paramList)

    paramList  go to state 56
    fnCall     go to state 57


State 25

   22 decl: LP DEFV . ATOM sExpn RP

    ATOM  shift, and go to state 58


State 26

   23 formatSt: LP FORMAT . TRUE LIT paramList RP

    TRUE  shift, and go to state 59


State 27

   51 logicalOP: EQ .

    $default  reduce using rule 51 (logicalOP)


State 28

   50 logicalOP: NE .

    $default  reduce using rule 50 (logicalOP)


State 29

   48 logicalOP: GT .

    $default  reduce using rule 48 (logicalOP)


State 30

   49 logicalOP: GTE .

    $default  reduce using rule 49 (logicalOP)


State 31

   52 logicalOP: LT .

    $default  reduce using rule 52 (logicalOP)


State 32

   53 logicalOP: LTE .

    $default  reduce using rule 53 (logicalOP)


State 33

   40 arithOP: MAX .

    $default  reduce using rule 40 (arithOP)


State 34

   41 arithOP: MIN .

    $default  reduce using rule 41 (arithOP)


State 35

   42 logicalOP: AND .

    $default  reduce using rule 42 (logicalOP)


State 36

   43 logicalOP: OR .

    $default  reduce using rule 43 (logicalOP)


State 37

   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   30      | LP NOT . seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   36 seOrAtom: . sExpn
   37         | . ATOM

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60
    ATOM   shift, and go to state 61

    sExpn     go to state 62
    seOrAtom  go to state 63


State 38

   44 logicalOP: LA .

    $default  reduce using rule 44 (logicalOP)


State 39

   45 logicalOP: LO .

    $default  reduce using rule 45 (logicalOP)


State 40

   46 logicalOP: LXOR .

    $default  reduce using rule 46 (logicalOP)


State 41

   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   31      | LP LNOR . seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   36 seOrAtom: . sExpn
   37         | . ATOM

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60
    ATOM   shift, and go to state 61

    sExpn     go to state 62
    seOrAtom  go to state 64


State 42

   47 logicalOP: LEQV .

    $default  reduce using rule 47 (logicalOP)


State 43

   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   36 seOrAtom: . sExpn
   37         | . ATOM
   54 decisionSt: LP IF . seOrAtom stList RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60
    ATOM   shift, and go to state 61

    sExpn     go to state 62
    seOrAtom  go to state 65


State 44

   59 blockSt: LP BLOCK . ATOM stList RP

    ATOM  shift, and go to state 66


State 45

   68 returnSt: LP RETURN . ATOM optionalRetVal RP

    ATOM  shift, and go to state 67


State 46

    2 stList: . stList stmt
    3       | . %empty  [TRUE, FALSE, NUM, LP, RP]
   60 loopSt: LP LOOP . forConstructs loopStList RP
   61       | LP LOOP . stList RP
   66 forConstructs: . forConstructs FOR ATOM IN SQ LP paramList RP
   67              | . %empty  [RP, FOR, DO, COLLECT]

    RP        reduce using rule 3 (stList)
    RP        [reduce using rule 67 (forConstructs)]
    FOR       reduce using rule 67 (forConstructs)
    DO        reduce using rule 67 (forConstructs)
    COLLECT   reduce using rule 67 (forConstructs)
    $default  reduce using rule 3 (stList)

    stList         go to state 68
    forConstructs  go to state 69


State 47

   55 decisionSt: LP COND . testCases RP
   57 testCases: . testCases LP sExpn stList RP
   58          | . %empty

    $default  reduce using rule 58 (testCases)

    testCases  go to state 70


State 48

   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   56 decisionSt: LP WHEN . sExpn stList RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60

    sExpn  go to state 71


State 49

   13 paramList: . paramList optionalSQ seOrAtom
   14          | . %empty
   27 sExpn: LP arithOP . paramList RP

    $default  reduce using rule 14 (paramList)

    paramList  go to state 72


State 50

   13 paramList: . paramList optionalSQ seOrAtom
   14          | . %empty
   32 sExpn: LP logicalOP . paramList RP

    $default  reduce using rule 14 (paramList)

    paramList  go to state 73


State 51

   28 sExpn: LP INCF ATOM . NUM RP

    NUM  shift, and go to state 74


State 52

   29 sExpn: LP DECF ATOM . NUM RP

    NUM  shift, and go to state 75


State 53

   24 fnDecl: LP DEFM ATOM . LP atomList RP optionalLIT stList RP

    LP  shift, and go to state 76


State 54

   21 decl: LP SETQ ATOM . sExpn RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60

    sExpn  go to state 77


State 55

   17 fnCall: LP . ATOM paramList RP
   18       | LP . ATOM fnCall RP

    ATOM  shift, and go to state 24


State 56

   13 paramList: paramList . optionalSQ seOrAtom
   17 fnCall: LP ATOM paramList . RP
   19 optionalSQ: . SQ
   20           | . %empty  [TRUE, FALSE, NUM, LP, ATOM]

    RP  shift, and go to state 78
    SQ  shift, and go to state 79

    $default  reduce using rule 20 (optionalSQ)

    optionalSQ  go to state 80


State 57

   18 fnCall: LP ATOM fnCall . RP

    RP  shift, and go to state 81


State 58

   22 decl: LP DEFV ATOM . sExpn RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60

    sExpn  go to state 82


State 59

   23 formatSt: LP FORMAT TRUE . LIT paramList RP

    LIT  shift, and go to state 83


State 60

   27 sExpn: LP . arithOP paramList RP
   28      | LP . INCF ATOM NUM RP
   29      | LP . DECF ATOM NUM RP
   30      | LP . NOT seOrAtom RP
   31      | LP . LNOR seOrAtom seOrAtom RP
   32      | LP . logicalOP paramList RP
   38 arithOP: . OP
   39        | . MOD
   40        | . MAX
   41        | . MIN
   42 logicalOP: . AND
   43          | . OR
   44          | . LA
   45          | . LO
   46          | . LXOR
   47          | . LEQV
   48          | . GT
   49          | . GTE
   50          | . NE
   51          | . EQ
   52          | . LT
   53          | . LTE

    MOD   shift, and go to state 18
    INCF  shift, and go to state 19
    DECF  shift, and go to state 20
    OP    shift, and go to state 23
    EQ    shift, and go to state 27
    NE    shift, and go to state 28
    GT    shift, and go to state 29
    GTE   shift, and go to state 30
    LT    shift, and go to state 31
    LTE   shift, and go to state 32
    MAX   shift, and go to state 33
    MIN   shift, and go to state 34
    AND   shift, and go to state 35
    OR    shift, and go to state 36
    NOT   shift, and go to state 37
    LA    shift, and go to state 38
    LO    shift, and go to state 39
    LXOR  shift, and go to state 40
    LNOR  shift, and go to state 41
    LEQV  shift, and go to state 42

    arithOP    go to state 49
    logicalOP  go to state 50


State 61

   37 seOrAtom: ATOM .

    $default  reduce using rule 37 (seOrAtom)


State 62

   36 seOrAtom: sExpn .

    $default  reduce using rule 36 (seOrAtom)


State 63

   30 sExpn: LP NOT seOrAtom . RP

    RP  shift, and go to state 84


State 64

   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   31      | LP LNOR seOrAtom . seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   36 seOrAtom: . sExpn
   37         | . ATOM

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60
    ATOM   shift, and go to state 61

    sExpn     go to state 62
    seOrAtom  go to state 85


State 65

    2 stList: . stList stmt
    3       | . %empty
   54 decisionSt: LP IF seOrAtom . stList RP

    $default  reduce using rule 3 (stList)

    stList  go to state 86


State 66

    2 stList: . stList stmt
    3       | . %empty
   59 blockSt: LP BLOCK ATOM . stList RP

    $default  reduce using rule 3 (stList)

    stList  go to state 87


State 67

   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   36 seOrAtom: . sExpn
   37         | . ATOM
   68 returnSt: LP RETURN ATOM . optionalRetVal RP
   69 optionalRetVal: . seOrAtom
   70               | . %empty  [RP]

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60
    ATOM   shift, and go to state 61

    $default  reduce using rule 70 (optionalRetVal)

    sExpn           go to state 62
    seOrAtom        go to state 88
    optionalRetVal  go to state 89


State 68

    2 stList: stList . stmt
    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   59 blockSt: . LP BLOCK ATOM stList RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   61       | LP LOOP stList . RP
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7
    RP     shift, and go to state 90

    stmt        go to state 8
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 69

   60 loopSt: LP LOOP forConstructs . loopStList RP
   62 loopStList: . loopStList execLoop
   63           | . %empty  [RP, DO, COLLECT]
   66 forConstructs: forConstructs . FOR ATOM IN SQ LP paramList RP

    FOR  shift, and go to state 91

    $default  reduce using rule 63 (loopStList)

    loopStList  go to state 92


State 70

   55 decisionSt: LP COND testCases . RP
   57 testCases: testCases . LP sExpn stList RP

    LP  shift, and go to state 93
    RP  shift, and go to state 94


State 71

    2 stList: . stList stmt
    3       | . %empty
   56 decisionSt: LP WHEN sExpn . stList RP

    $default  reduce using rule 3 (stList)

    stList  go to state 95


State 72

   13 paramList: paramList . optionalSQ seOrAtom
   19 optionalSQ: . SQ
   20           | . %empty  [TRUE, FALSE, NUM, LP, ATOM]
   27 sExpn: LP arithOP paramList . RP

    RP  shift, and go to state 96
    SQ  shift, and go to state 79

    $default  reduce using rule 20 (optionalSQ)

    optionalSQ  go to state 80


State 73

   13 paramList: paramList . optionalSQ seOrAtom
   19 optionalSQ: . SQ
   20           | . %empty  [TRUE, FALSE, NUM, LP, ATOM]
   32 sExpn: LP logicalOP paramList . RP

    RP  shift, and go to state 97
    SQ  shift, and go to state 79

    $default  reduce using rule 20 (optionalSQ)

    optionalSQ  go to state 80


State 74

   28 sExpn: LP INCF ATOM NUM . RP

    RP  shift, and go to state 98


State 75

   29 sExpn: LP DECF ATOM NUM . RP

    RP  shift, and go to state 99


State 76

   15 atomList: . atomList ATOM
   16         | . %empty
   24 fnDecl: LP DEFM ATOM LP . atomList RP optionalLIT stList RP

    $default  reduce using rule 16 (atomList)

    atomList  go to state 100


State 77

   21 decl: LP SETQ ATOM sExpn . RP

    RP  shift, and go to state 101


State 78

   17 fnCall: LP ATOM paramList RP .

    $default  reduce using rule 17 (fnCall)


State 79

   19 optionalSQ: SQ .

    $default  reduce using rule 19 (optionalSQ)


State 80

   13 paramList: paramList optionalSQ . seOrAtom
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   36 seOrAtom: . sExpn
   37         | . ATOM

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60
    ATOM   shift, and go to state 61

    sExpn     go to state 62
    seOrAtom  go to state 102


State 81

   18 fnCall: LP ATOM fnCall RP .

    $default  reduce using rule 18 (fnCall)


State 82

   22 decl: LP DEFV ATOM sExpn . RP

    RP  shift, and go to state 103


State 83

   13 paramList: . paramList optionalSQ seOrAtom
   14          | . %empty
   23 formatSt: LP FORMAT TRUE LIT . paramList RP

    $default  reduce using rule 14 (paramList)

    paramList  go to state 104


State 84

   30 sExpn: LP NOT seOrAtom RP .

    $default  reduce using rule 30 (sExpn)


State 85

   31 sExpn: LP LNOR seOrAtom seOrAtom . RP

    RP  shift, and go to state 105


State 86

    2 stList: stList . stmt
    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   54           | LP IF seOrAtom stList . RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   59 blockSt: . LP BLOCK ATOM stList RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7
    RP     shift, and go to state 106

    stmt        go to state 8
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 87

    2 stList: stList . stmt
    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   59 blockSt: . LP BLOCK ATOM stList RP
   59        | LP BLOCK ATOM stList . RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7
    RP     shift, and go to state 107

    stmt        go to state 8
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 88

   69 optionalRetVal: seOrAtom .

    $default  reduce using rule 69 (optionalRetVal)


State 89

   68 returnSt: LP RETURN ATOM optionalRetVal . RP

    RP  shift, and go to state 108


State 90

   61 loopSt: LP LOOP stList RP .

    $default  reduce using rule 61 (loopSt)


State 91

   66 forConstructs: forConstructs FOR . ATOM IN SQ LP paramList RP

    ATOM  shift, and go to state 109


State 92

   60 loopSt: LP LOOP forConstructs loopStList . RP
   62 loopStList: loopStList . execLoop
   64 execLoop: . DO stmt
   65         | . COLLECT LP atomList RP

    RP       shift, and go to state 110
    DO       shift, and go to state 111
    COLLECT  shift, and go to state 112

    execLoop  go to state 113


State 93

   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   57 testCases: testCases LP . sExpn stList RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 60

    sExpn  go to state 114


State 94

   55 decisionSt: LP COND testCases RP .

    $default  reduce using rule 55 (decisionSt)


State 95

    2 stList: stList . stmt
    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   56           | LP WHEN sExpn stList . RP
   59 blockSt: . LP BLOCK ATOM stList RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7
    RP     shift, and go to state 115

    stmt        go to state 8
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 96

   27 sExpn: LP arithOP paramList RP .

    $default  reduce using rule 27 (sExpn)


State 97

   32 sExpn: LP logicalOP paramList RP .

    $default  reduce using rule 32 (sExpn)


State 98

   28 sExpn: LP INCF ATOM NUM RP .

    $default  reduce using rule 28 (sExpn)


State 99

   29 sExpn: LP DECF ATOM NUM RP .

    $default  reduce using rule 29 (sExpn)


State 100

   15 atomList: atomList . ATOM
   24 fnDecl: LP DEFM ATOM LP atomList . RP optionalLIT stList RP

    RP    shift, and go to state 116
    ATOM  shift, and go to state 117


State 101

   21 decl: LP SETQ ATOM sExpn RP .

    $default  reduce using rule 21 (decl)


State 102

   13 paramList: paramList optionalSQ seOrAtom .

    $default  reduce using rule 13 (paramList)


State 103

   22 decl: LP DEFV ATOM sExpn RP .

    $default  reduce using rule 22 (decl)


State 104

   13 paramList: paramList . optionalSQ seOrAtom
   19 optionalSQ: . SQ
   20           | . %empty  [TRUE, FALSE, NUM, LP, ATOM]
   23 formatSt: LP FORMAT TRUE LIT paramList . RP

    RP  shift, and go to state 118
    SQ  shift, and go to state 79

    $default  reduce using rule 20 (optionalSQ)

    optionalSQ  go to state 80


State 105

   31 sExpn: LP LNOR seOrAtom seOrAtom RP .

    $default  reduce using rule 31 (sExpn)


State 106

   54 decisionSt: LP IF seOrAtom stList RP .

    $default  reduce using rule 54 (decisionSt)


State 107

   59 blockSt: LP BLOCK ATOM stList RP .

    $default  reduce using rule 59 (blockSt)


State 108

   68 returnSt: LP RETURN ATOM optionalRetVal RP .

    $default  reduce using rule 68 (returnSt)


State 109

   66 forConstructs: forConstructs FOR ATOM . IN SQ LP paramList RP

    IN  shift, and go to state 119


State 110

   60 loopSt: LP LOOP forConstructs loopStList RP .

    $default  reduce using rule 60 (loopSt)


State 111

    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   59 blockSt: . LP BLOCK ATOM stList RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   64 execLoop: DO . stmt
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7

    stmt        go to state 120
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 112

   65 execLoop: COLLECT . LP atomList RP

    LP  shift, and go to state 121


State 113

   62 loopStList: loopStList execLoop .

    $default  reduce using rule 62 (loopStList)


State 114

    2 stList: . stList stmt
    3       | . %empty
   57 testCases: testCases LP sExpn . stList RP

    $default  reduce using rule 3 (stList)

    stList  go to state 122


State 115

   56 decisionSt: LP WHEN sExpn stList RP .

    $default  reduce using rule 56 (decisionSt)


State 116

   24 fnDecl: LP DEFM ATOM LP atomList RP . optionalLIT stList RP
   25 optionalLIT: . LIT
   26            | . %empty  [TRUE, FALSE, NUM, LP, RP]

    LIT  shift, and go to state 123

    $default  reduce using rule 26 (optionalLIT)

    optionalLIT  go to state 124


State 117

   15 atomList: atomList ATOM .

    $default  reduce using rule 15 (atomList)


State 118

   23 formatSt: LP FORMAT TRUE LIT paramList RP .

    $default  reduce using rule 23 (formatSt)


State 119

   66 forConstructs: forConstructs FOR ATOM IN . SQ LP paramList RP

    SQ  shift, and go to state 125


State 120

   64 execLoop: DO stmt .

    $default  reduce using rule 64 (execLoop)


State 121

   15 atomList: . atomList ATOM
   16         | . %empty
   65 execLoop: COLLECT LP . atomList RP

    $default  reduce using rule 16 (atomList)

    atomList  go to state 126


State 122

    2 stList: stList . stmt
    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   57 testCases: testCases LP sExpn stList . RP
   59 blockSt: . LP BLOCK ATOM stList RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7
    RP     shift, and go to state 127

    stmt        go to state 8
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 123

   25 optionalLIT: LIT .

    $default  reduce using rule 25 (optionalLIT)


State 124

    2 stList: . stList stmt
    3       | . %empty
   24 fnDecl: LP DEFM ATOM LP atomList RP optionalLIT . stList RP

    $default  reduce using rule 3 (stList)

    stList  go to state 128


State 125

   66 forConstructs: forConstructs FOR ATOM IN SQ . LP paramList RP

    LP  shift, and go to state 129


State 126

   15 atomList: atomList . ATOM
   65 execLoop: COLLECT LP atomList . RP

    RP    shift, and go to state 130
    ATOM  shift, and go to state 117


State 127

   57 testCases: testCases LP sExpn stList RP .

    $default  reduce using rule 57 (testCases)


State 128

    2 stList: stList . stmt
    4 stmt: . fnCall
    5     | . formatSt
    6     | . decl
    7     | . sExpn
    8     | . fnDecl
    9     | . blockSt
   10     | . returnSt
   11     | . decisionSt
   12     | . loopSt
   17 fnCall: . LP ATOM paramList RP
   18       | . LP ATOM fnCall RP
   21 decl: . LP SETQ ATOM sExpn RP
   22     | . LP DEFV ATOM sExpn RP
   23 formatSt: . LP FORMAT TRUE LIT paramList RP
   24 fnDecl: . LP DEFM ATOM LP atomList RP optionalLIT stList RP
   24       | LP DEFM ATOM LP atomList RP optionalLIT stList . RP
   27 sExpn: . LP arithOP paramList RP
   28      | . LP INCF ATOM NUM RP
   29      | . LP DECF ATOM NUM RP
   30      | . LP NOT seOrAtom RP
   31      | . LP LNOR seOrAtom seOrAtom RP
   32      | . LP logicalOP paramList RP
   33      | . NUM
   34      | . TRUE
   35      | . FALSE
   54 decisionSt: . LP IF seOrAtom stList RP
   55           | . LP COND testCases RP
   56           | . LP WHEN sExpn stList RP
   59 blockSt: . LP BLOCK ATOM stList RP
   60 loopSt: . LP LOOP forConstructs loopStList RP
   61       | . LP LOOP stList RP
   68 returnSt: . LP RETURN ATOM optionalRetVal RP

    TRUE   shift, and go to state 4
    FALSE  shift, and go to state 5
    NUM    shift, and go to state 6
    LP     shift, and go to state 7
    RP     shift, and go to state 131

    stmt        go to state 8
    fnCall      go to state 9
    decl        go to state 10
    formatSt    go to state 11
    fnDecl      go to state 12
    sExpn       go to state 13
    decisionSt  go to state 14
    blockSt     go to state 15
    loopSt      go to state 16
    returnSt    go to state 17


State 129

   13 paramList: . paramList optionalSQ seOrAtom
   14          | . %empty
   66 forConstructs: forConstructs FOR ATOM IN SQ LP . paramList RP

    $default  reduce using rule 14 (paramList)

    paramList  go to state 132


State 130

   65 execLoop: COLLECT LP atomList RP .

    $default  reduce using rule 65 (execLoop)


State 131

   24 fnDecl: LP DEFM ATOM LP atomList RP optionalLIT stList RP .

    $default  reduce using rule 24 (fnDecl)


State 132

   13 paramList: paramList . optionalSQ seOrAtom
   19 optionalSQ: . SQ
   20           | . %empty  [TRUE, FALSE, NUM, LP, ATOM]
   66 forConstructs: forConstructs FOR ATOM IN SQ LP paramList . RP

    RP  shift, and go to state 133
    SQ  shift, and go to state 79

    $default  reduce using rule 20 (optionalSQ)

    optionalSQ  go to state 80


State 133

   66 forConstructs: forConstructs FOR ATOM IN SQ LP paramList RP .

    $default  reduce using rule 66 (forConstructs)
